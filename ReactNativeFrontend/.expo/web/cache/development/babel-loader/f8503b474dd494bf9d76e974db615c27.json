{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport invariant from 'invariant';\nimport { CameraType, ImageType } from \"./CameraModule.types\";\nimport * as Utils from \"./CameraUtils\";\nimport * as CapabilityUtils from \"./CapabilityUtils\";\nimport { isBackCameraAvailableAsync, isFrontCameraAvailableAsync, canGetUserMedia } from \"./UserMediaManager\";\nimport { FacingModeToCameraType, PictureSizes } from \"./constants\";\nexport { ImageType, CameraType };\nvar VALID_SETTINGS_KEYS = ['autoFocus', 'flashMode', 'exposureCompensation', 'colorTemperature', 'iso', 'brightness', 'contrast', 'saturation', 'sharpness', 'focusDistance', 'whiteBalance', 'zoom'];\n\nvar CameraModule = function () {\n  function CameraModule(videoElement) {\n    var _this = this;\n\n    _classCallCheck(this, CameraModule);\n\n    this.videoElement = videoElement;\n\n    this.onCameraReady = function () {};\n\n    this.onMountError = function () {};\n\n    this.stream = null;\n    this.settings = null;\n    this.isStartingCamera = false;\n    this.cameraType = CameraType.front;\n    this.webCameraSettings = {\n      autoFocus: 'continuous',\n      flashMode: 'off',\n      whiteBalance: 'continuous',\n      zoom: 1\n    };\n\n    this.getAvailablePictureSizes = function _callee(ratio) {\n      return _regeneratorRuntime.async(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", PictureSizes);\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    };\n\n    if (this.videoElement) {\n      this.videoElement.addEventListener('loadedmetadata', function () {\n        _this.syncTrackCapabilities();\n      });\n    }\n  }\n\n  _createClass(CameraModule, [{\n    key: \"updateWebCameraSettingsAsync\",\n    value: function updateWebCameraSettingsAsync(nextSettings) {\n      var changes, _i, _Object$keys, key, nextValue, hasChanges;\n\n      return _regeneratorRuntime.async(function updateWebCameraSettingsAsync$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              changes = {};\n              _i = 0, _Object$keys = Object.keys(nextSettings);\n\n            case 2:\n              if (!(_i < _Object$keys.length)) {\n                _context2.next = 11;\n                break;\n              }\n\n              key = _Object$keys[_i];\n\n              if (VALID_SETTINGS_KEYS.includes(key)) {\n                _context2.next = 6;\n                break;\n              }\n\n              return _context2.abrupt(\"continue\", 8);\n\n            case 6:\n              nextValue = nextSettings[key];\n\n              if (nextValue !== this.webCameraSettings[key]) {\n                changes[key] = nextValue;\n              }\n\n            case 8:\n              _i++;\n              _context2.next = 2;\n              break;\n\n            case 11:\n              hasChanges = !!Object.keys(changes).length;\n              this.webCameraSettings = _objectSpread(_objectSpread({}, this.webCameraSettings), changes);\n\n              if (!hasChanges) {\n                _context2.next = 16;\n                break;\n              }\n\n              _context2.next = 16;\n              return _regeneratorRuntime.awrap(this.syncTrackCapabilities(changes));\n\n            case 16:\n              return _context2.abrupt(\"return\", hasChanges);\n\n            case 17:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"setTypeAsync\",\n    value: function setTypeAsync(value) {\n      return _regeneratorRuntime.async(function setTypeAsync$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!(value === this.cameraType)) {\n                _context3.next = 2;\n                break;\n              }\n\n              return _context3.abrupt(\"return\");\n\n            case 2:\n              this.cameraType = value;\n              _context3.next = 5;\n              return _regeneratorRuntime.awrap(this.resumePreview());\n\n            case 5:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"setPictureSize\",\n    value: function setPictureSize(value) {\n      if (value === this.pictureSize) {\n        return;\n      }\n\n      invariant(PictureSizes.includes(value), \"expo-camera: CameraModule.setPictureSize(): invalid size supplied \" + value + \", expected one of: \" + PictureSizes.join(', '));\n      this.pictureSize = value;\n    }\n  }, {\n    key: \"isTorchAvailable\",\n    value: function isTorchAvailable() {\n      return isCapabilityAvailable(this.videoElement, 'torch');\n    }\n  }, {\n    key: \"isZoomAvailable\",\n    value: function isZoomAvailable() {\n      return isCapabilityAvailable(this.videoElement, 'zoom');\n    }\n  }, {\n    key: \"onCapabilitiesReady\",\n    value: function onCapabilitiesReady(track) {\n      var _this2 = this;\n\n      var settings,\n          capabilities,\n          constraints,\n          clampedValues,\n          _i2,\n          _clampedValues,\n          property,\n          _validatedConstrainedValue,\n          _args4 = arguments;\n\n      return _regeneratorRuntime.async(function onCapabilitiesReady$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              settings = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};\n              capabilities = track.getCapabilities();\n              constraints = {};\n              clampedValues = ['exposureCompensation', 'colorTemperature', 'iso', 'brightness', 'contrast', 'saturation', 'sharpness', 'focusDistance', 'zoom'];\n\n              for (_i2 = 0, _clampedValues = clampedValues; _i2 < _clampedValues.length; _i2++) {\n                property = _clampedValues[_i2];\n\n                if (capabilities[property]) {\n                  constraints[property] = convertNormalizedSetting(capabilities[property], settings[property]);\n                }\n              }\n\n              _validatedConstrainedValue = function _validatedConstrainedValue(key, propName, converter) {\n                return validatedConstrainedValue(key, propName, converter(settings[propName]), capabilities, settings, _this2.cameraType);\n              };\n\n              if (capabilities.focusMode && settings.autoFocus !== undefined) {\n                constraints.focusMode = _validatedConstrainedValue('focusMode', 'autoFocus', CapabilityUtils.convertAutoFocusJSONToNative);\n              }\n\n              if (capabilities.torch && settings.flashMode !== undefined) {\n                constraints.torch = _validatedConstrainedValue('torch', 'flashMode', CapabilityUtils.convertFlashModeJSONToNative);\n              }\n\n              if (capabilities.whiteBalanceMode && settings.whiteBalance !== undefined) {\n                constraints.whiteBalanceMode = _validatedConstrainedValue('whiteBalanceMode', 'whiteBalance', CapabilityUtils.convertWhiteBalanceJSONToNative);\n              }\n\n              _context4.next = 11;\n              return _regeneratorRuntime.awrap(track.applyConstraints({\n                advanced: [constraints]\n              }));\n\n            case 11:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"applyVideoConstraints\",\n    value: function applyVideoConstraints(constraints) {\n      return _regeneratorRuntime.async(function applyVideoConstraints$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              if (!(!this.stream || !this.stream.getVideoTracks)) {\n                _context5.next = 2;\n                break;\n              }\n\n              return _context5.abrupt(\"return\", false);\n\n            case 2:\n              _context5.next = 4;\n              return _regeneratorRuntime.awrap(applyConstraints(this.stream.getVideoTracks(), constraints));\n\n            case 4:\n              return _context5.abrupt(\"return\", _context5.sent);\n\n            case 5:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"applyAudioConstraints\",\n    value: function applyAudioConstraints(constraints) {\n      return _regeneratorRuntime.async(function applyAudioConstraints$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              if (!(!this.stream || !this.stream.getAudioTracks)) {\n                _context6.next = 2;\n                break;\n              }\n\n              return _context6.abrupt(\"return\", false);\n\n            case 2:\n              _context6.next = 4;\n              return _regeneratorRuntime.awrap(applyConstraints(this.stream.getAudioTracks(), constraints));\n\n            case 4:\n              return _context6.abrupt(\"return\", _context6.sent);\n\n            case 5:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"syncTrackCapabilities\",\n    value: function syncTrackCapabilities() {\n      var _this3 = this;\n\n      var settings,\n          _args7 = arguments;\n      return _regeneratorRuntime.async(function syncTrackCapabilities$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              settings = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : {};\n\n              if (!(this.stream && this.stream.getVideoTracks)) {\n                _context7.next = 4;\n                break;\n              }\n\n              _context7.next = 4;\n              return _regeneratorRuntime.awrap(Promise.all(this.stream.getVideoTracks().map(function (track) {\n                return _this3.onCapabilitiesReady(track, settings);\n              })));\n\n            case 4:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"setStream\",\n    value: function setStream(stream) {\n      this.stream = stream;\n      this.settings = stream ? stream.getTracks()[0].getSettings() : null;\n      setVideoSource(this.videoElement, stream);\n    }\n  }, {\n    key: \"getActualCameraType\",\n    value: function getActualCameraType() {\n      if (this.settings) {\n        var _this$settings$facing = this.settings.facingMode,\n            facingMode = _this$settings$facing === void 0 ? 'user' : _this$settings$facing;\n        return FacingModeToCameraType[facingMode];\n      }\n\n      return null;\n    }\n  }, {\n    key: \"ensureCameraIsRunningAsync\",\n    value: function ensureCameraIsRunningAsync() {\n      return _regeneratorRuntime.async(function ensureCameraIsRunningAsync$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              if (this.stream) {\n                _context8.next = 3;\n                break;\n              }\n\n              _context8.next = 3;\n              return _regeneratorRuntime.awrap(this.resumePreview());\n\n            case 3:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"resumePreview\",\n    value: function resumePreview() {\n      var stream;\n      return _regeneratorRuntime.async(function resumePreview$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              if (!this.isStartingCamera) {\n                _context9.next = 2;\n                break;\n              }\n\n              return _context9.abrupt(\"return\", null);\n\n            case 2:\n              this.isStartingCamera = true;\n              _context9.prev = 3;\n              this.stopAsync();\n              _context9.next = 7;\n              return _regeneratorRuntime.awrap(Utils.getStreamDevice(this.type));\n\n            case 7:\n              stream = _context9.sent;\n              this.setStream(stream);\n              this.isStartingCamera = false;\n              this.onCameraReady();\n              return _context9.abrupt(\"return\", stream);\n\n            case 14:\n              _context9.prev = 14;\n              _context9.t0 = _context9[\"catch\"](3);\n              this.isStartingCamera = false;\n              this.onMountError({\n                nativeEvent: _context9.t0\n              });\n\n            case 18:\n              return _context9.abrupt(\"return\", null);\n\n            case 19:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n      }, null, this, [[3, 14]], Promise);\n    }\n  }, {\n    key: \"takePicture\",\n    value: function takePicture(config) {\n      var base64 = Utils.captureImage(this.videoElement, config);\n      var capturedPicture = {\n        uri: base64,\n        base64: base64,\n        width: 0,\n        height: 0\n      };\n\n      if (this.settings) {\n        var _this$settings = this.settings,\n            _this$settings$width = _this$settings.width,\n            width = _this$settings$width === void 0 ? 0 : _this$settings$width,\n            _this$settings$height = _this$settings.height,\n            height = _this$settings$height === void 0 ? 0 : _this$settings$height;\n        capturedPicture.width = width;\n        capturedPicture.height = height;\n        capturedPicture.exif = this.settings;\n      }\n\n      if (config.onPictureSaved) {\n        config.onPictureSaved({\n          nativeEvent: {\n            data: capturedPicture,\n            id: config.id\n          }\n        });\n      }\n\n      return capturedPicture;\n    }\n  }, {\n    key: \"stopAsync\",\n    value: function stopAsync() {\n      stopMediaStream(this.stream);\n      this.setStream(null);\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this.cameraType;\n    }\n  }], [{\n    key: \"getAvailableCameraTypesAsync\",\n    value: function getAvailableCameraTypesAsync() {\n      var devices, types;\n      return _regeneratorRuntime.async(function getAvailableCameraTypesAsync$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              if (!(!canGetUserMedia() || !navigator.mediaDevices.enumerateDevices)) {\n                _context10.next = 2;\n                break;\n              }\n\n              return _context10.abrupt(\"return\", []);\n\n            case 2:\n              _context10.next = 4;\n              return _regeneratorRuntime.awrap(navigator.mediaDevices.enumerateDevices());\n\n            case 4:\n              devices = _context10.sent;\n              _context10.t0 = _regeneratorRuntime;\n              _context10.t1 = Promise;\n              _context10.next = 9;\n              return _regeneratorRuntime.awrap(isFrontCameraAvailableAsync(devices));\n\n            case 9:\n              _context10.t2 = _context10.sent;\n\n              if (!_context10.t2) {\n                _context10.next = 12;\n                break;\n              }\n\n              _context10.t2 = CameraType.front;\n\n            case 12:\n              _context10.t3 = _context10.t2;\n              _context10.next = 15;\n              return _regeneratorRuntime.awrap(isBackCameraAvailableAsync());\n\n            case 15:\n              _context10.t4 = _context10.sent;\n\n              if (!_context10.t4) {\n                _context10.next = 18;\n                break;\n              }\n\n              _context10.t4 = CameraType.back;\n\n            case 18:\n              _context10.t5 = _context10.t4;\n              _context10.t6 = [_context10.t3, _context10.t5];\n              _context10.t7 = _context10.t1.all.call(_context10.t1, _context10.t6);\n              _context10.next = 23;\n              return _context10.t0.awrap.call(_context10.t0, _context10.t7);\n\n            case 23:\n              types = _context10.sent;\n              return _context10.abrupt(\"return\", types.filter(Boolean));\n\n            case 25:\n            case \"end\":\n              return _context10.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }]);\n\n  return CameraModule;\n}();\n\nfunction stopMediaStream(stream) {\n  if (!stream) return;\n  if (stream.getAudioTracks) stream.getAudioTracks().forEach(function (track) {\n    return track.stop();\n  });\n  if (stream.getVideoTracks) stream.getVideoTracks().forEach(function (track) {\n    return track.stop();\n  });\n  if (isMediaStreamTrack(stream)) stream.stop();\n}\n\nfunction setVideoSource(video, stream) {\n  try {\n    video.srcObject = stream;\n  } catch (_) {\n    if (stream) {\n      video.src = window.URL.createObjectURL(stream);\n    } else if (typeof video.src === 'string') {\n      window.URL.revokeObjectURL(video.src);\n    }\n  }\n}\n\nfunction applyConstraints(tracks, constraints) {\n  return _regeneratorRuntime.async(function applyConstraints$(_context12) {\n    while (1) {\n      switch (_context12.prev = _context12.next) {\n        case 0:\n          _context12.prev = 0;\n          _context12.next = 3;\n          return _regeneratorRuntime.awrap(Promise.all(tracks.map(function _callee2(track) {\n            return _regeneratorRuntime.async(function _callee2$(_context11) {\n              while (1) {\n                switch (_context11.prev = _context11.next) {\n                  case 0:\n                    _context11.next = 2;\n                    return _regeneratorRuntime.awrap(track.applyConstraints({\n                      advanced: [constraints]\n                    }));\n\n                  case 2:\n                  case \"end\":\n                    return _context11.stop();\n                }\n              }\n            }, null, null, null, Promise);\n          })));\n\n        case 3:\n          return _context12.abrupt(\"return\", true);\n\n        case 6:\n          _context12.prev = 6;\n          _context12.t0 = _context12[\"catch\"](0);\n          return _context12.abrupt(\"return\", false);\n\n        case 9:\n        case \"end\":\n          return _context12.stop();\n      }\n    }\n  }, null, null, [[0, 6]], Promise);\n}\n\nfunction isCapabilityAvailable(video, keyName) {\n  var stream = video.srcObject;\n\n  if (stream instanceof MediaStream) {\n    var videoTrack = stream.getVideoTracks()[0];\n\n    if (typeof videoTrack.getCapabilities === 'undefined') {\n      return false;\n    }\n\n    var _capabilities = videoTrack.getCapabilities();\n\n    return !!_capabilities[keyName];\n  }\n\n  return false;\n}\n\nfunction isMediaStreamTrack(input) {\n  return typeof input.stop === 'function';\n}\n\nfunction convertNormalizedSetting(range, value) {\n  if (!value) return;\n  var converted = convertRange(value, [range.min, range.max]);\n  return Math.min(range.max, Math.max(range.min, converted));\n}\n\nfunction convertRange(value, r2) {\n  var r1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 1];\n  return (value - r1[0]) * (r2[1] - r2[0]) / (r1[1] - r1[0]) + r2[0];\n}\n\nfunction validatedConstrainedValue(constraintKey, settingsKey, convertedSetting, capabilities, settings, cameraType) {\n  var setting = settings[settingsKey];\n\n  if (Array.isArray(capabilities[constraintKey]) && convertedSetting && !capabilities[constraintKey].includes(convertedSetting)) {\n    console.warn(\" { \" + settingsKey + \": \\\"\" + setting + \"\\\" } (converted to \\\"\" + convertedSetting + \"\\\" in the browser) is not supported for camera type \\\"\" + cameraType + \"\\\" in your browser. Using the default value instead.\");\n    return undefined;\n  }\n\n  return convertedSetting;\n}\n\nexport default CameraModule;","map":{"version":3,"sources":["../../src/CameraModule/CameraModule.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-env browser */\nimport invariant from 'invariant';\n\nimport { CameraPictureOptions } from '../Camera.types';\nimport { CameraType, CapturedPicture, CaptureOptions, ImageType } from './CameraModule.types';\nimport * as Utils from './CameraUtils';\nimport * as CapabilityUtils from './CapabilityUtils';\nimport {\n  isBackCameraAvailableAsync,\n  isFrontCameraAvailableAsync,\n  canGetUserMedia,\n} from './UserMediaManager';\nimport { FacingModeToCameraType, PictureSizes } from './constants';\n\nexport { ImageType, CameraType, CaptureOptions };\n\ntype OnCameraReadyListener = () => void;\ntype OnMountErrorListener = (event: { nativeEvent: Error }) => void;\n\nexport type WebCameraSettings = Partial<{\n  autoFocus: string;\n  flashMode: string;\n  whiteBalance: string;\n  exposureCompensation: number;\n  colorTemperature: number;\n  iso: number;\n  brightness: number;\n  contrast: number;\n  saturation: number;\n  sharpness: number;\n  focusDistance: number;\n  zoom: number;\n}>;\n\nconst VALID_SETTINGS_KEYS = [\n  'autoFocus',\n  'flashMode',\n  'exposureCompensation',\n  'colorTemperature',\n  'iso',\n  'brightness',\n  'contrast',\n  'saturation',\n  'sharpness',\n  'focusDistance',\n  'whiteBalance',\n  'zoom',\n];\n\nclass CameraModule {\n  public onCameraReady: OnCameraReadyListener = () => {};\n  public onMountError: OnMountErrorListener = () => {};\n  private stream: MediaStream | null = null;\n  private settings: MediaTrackSettings | null = null;\n  private pictureSize?: string;\n  private isStartingCamera = false;\n  private cameraType: CameraType = CameraType.front;\n  private webCameraSettings: WebCameraSettings = {\n    autoFocus: 'continuous',\n    flashMode: 'off',\n    whiteBalance: 'continuous',\n    zoom: 1,\n  };\n\n  public get type(): CameraType {\n    return this.cameraType;\n  }\n\n  constructor(private videoElement: HTMLVideoElement) {\n    if (this.videoElement) {\n      this.videoElement.addEventListener('loadedmetadata', () => {\n        this.syncTrackCapabilities();\n      });\n    }\n  }\n\n  public async updateWebCameraSettingsAsync(nextSettings: {\n    [key: string]: any;\n  }): Promise<boolean> {\n    const changes: WebCameraSettings = {};\n\n    for (const key of Object.keys(nextSettings)) {\n      if (!VALID_SETTINGS_KEYS.includes(key)) continue;\n      const nextValue = nextSettings[key];\n      if (nextValue !== this.webCameraSettings[key]) {\n        changes[key] = nextValue;\n      }\n    }\n\n    // Only update the native camera if changes were found\n    const hasChanges = !!Object.keys(changes).length;\n\n    this.webCameraSettings = { ...this.webCameraSettings, ...changes };\n    if (hasChanges) {\n      await this.syncTrackCapabilities(changes);\n    }\n\n    return hasChanges;\n  }\n\n  public async setTypeAsync(value: CameraType) {\n    if (value === this.cameraType) {\n      return;\n    }\n    this.cameraType = value;\n\n    await this.resumePreview();\n  }\n\n  public setPictureSize(value: string) {\n    if (value === this.pictureSize) {\n      return;\n    }\n    invariant(\n      PictureSizes.includes(value),\n      `expo-camera: CameraModule.setPictureSize(): invalid size supplied ${value}, expected one of: ${PictureSizes.join(\n        ', '\n      )}`\n    );\n\n    // TODO: Bacon: IMP\n    // const [width, height] = value.split('x');\n    // const aspectRatio = parseFloat(width) / parseFloat(height);\n\n    this.pictureSize = value;\n  }\n\n  public isTorchAvailable(): boolean {\n    return isCapabilityAvailable(this.videoElement, 'torch');\n  }\n\n  public isZoomAvailable(): boolean {\n    return isCapabilityAvailable(this.videoElement, 'zoom');\n  }\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints\n  private async onCapabilitiesReady(\n    track: MediaStreamTrack,\n    settings: WebCameraSettings = {}\n  ): Promise<void> {\n    const capabilities = track.getCapabilities();\n\n    // Create an empty object because if you set a constraint that isn't available an error will be thrown.\n    const constraints: MediaTrackConstraintSet = {};\n\n    // TODO: Bacon: Add `pointsOfInterest` support\n    const clampedValues = [\n      'exposureCompensation',\n      'colorTemperature',\n      'iso',\n      'brightness',\n      'contrast',\n      'saturation',\n      'sharpness',\n      'focusDistance',\n      'zoom',\n    ];\n\n    for (const property of clampedValues) {\n      if (capabilities[property]) {\n        constraints[property] = convertNormalizedSetting(\n          capabilities[property],\n          settings[property]\n        );\n      }\n    }\n\n    const _validatedConstrainedValue = (key, propName, converter) =>\n      validatedConstrainedValue(\n        key,\n        propName,\n        converter(settings[propName]),\n        capabilities,\n        settings,\n        this.cameraType\n      );\n\n    if (capabilities.focusMode && settings.autoFocus !== undefined) {\n      constraints.focusMode = _validatedConstrainedValue(\n        'focusMode',\n        'autoFocus',\n        CapabilityUtils.convertAutoFocusJSONToNative\n      );\n    }\n\n    if (capabilities.torch && settings.flashMode !== undefined) {\n      constraints.torch = _validatedConstrainedValue(\n        'torch',\n        'flashMode',\n        CapabilityUtils.convertFlashModeJSONToNative\n      );\n    }\n\n    if (capabilities.whiteBalanceMode && settings.whiteBalance !== undefined) {\n      constraints.whiteBalanceMode = _validatedConstrainedValue(\n        'whiteBalanceMode',\n        'whiteBalance',\n        CapabilityUtils.convertWhiteBalanceJSONToNative\n      );\n    }\n\n    await track.applyConstraints({ advanced: [constraints] as any });\n  }\n\n  private async applyVideoConstraints(constraints: { [key: string]: any }): Promise<boolean> {\n    if (!this.stream || !this.stream.getVideoTracks) {\n      return false;\n    }\n    return await applyConstraints(this.stream.getVideoTracks(), constraints);\n  }\n\n  private async applyAudioConstraints(constraints: { [key: string]: any }): Promise<boolean> {\n    if (!this.stream || !this.stream.getAudioTracks) {\n      return false;\n    }\n    return await applyConstraints(this.stream.getAudioTracks(), constraints);\n  }\n\n  private async syncTrackCapabilities(settings: WebCameraSettings = {}): Promise<void> {\n    if (this.stream && this.stream.getVideoTracks) {\n      await Promise.all(\n        this.stream.getVideoTracks().map(track => this.onCapabilitiesReady(track, settings))\n      );\n    }\n  }\n\n  private setStream(stream: MediaStream | null): void {\n    this.stream = stream;\n    this.settings = stream ? stream.getTracks()[0].getSettings() : null;\n    setVideoSource(this.videoElement, stream);\n  }\n\n  public getActualCameraType(): CameraType | null {\n    if (this.settings) {\n      // On desktop no value will be returned, in this case we should assume the cameraType is 'front'\n      const { facingMode = 'user' } = this.settings;\n      return FacingModeToCameraType[facingMode];\n    }\n    return null;\n  }\n\n  public async ensureCameraIsRunningAsync(): Promise<void> {\n    if (!this.stream) {\n      await this.resumePreview();\n    }\n  }\n\n  public async resumePreview(): Promise<MediaStream | null> {\n    if (this.isStartingCamera) {\n      return null;\n    }\n    this.isStartingCamera = true;\n    try {\n      this.stopAsync();\n      const stream = await Utils.getStreamDevice(this.type);\n      this.setStream(stream);\n      this.isStartingCamera = false;\n      this.onCameraReady();\n      return stream;\n    } catch (error) {\n      this.isStartingCamera = false;\n      this.onMountError({ nativeEvent: error });\n    }\n    return null;\n  }\n\n  public takePicture(config: CameraPictureOptions): CapturedPicture {\n    const base64 = Utils.captureImage(this.videoElement, config);\n\n    const capturedPicture: CapturedPicture = {\n      uri: base64,\n      base64,\n      width: 0,\n      height: 0,\n    };\n\n    if (this.settings) {\n      const { width = 0, height = 0 } = this.settings;\n      capturedPicture.width = width;\n      capturedPicture.height = height;\n      // TODO: Bacon: verify/enforce exif shape.\n      capturedPicture.exif = this.settings;\n    }\n\n    if (config.onPictureSaved) {\n      config.onPictureSaved({ nativeEvent: { data: capturedPicture, id: config.id } });\n    }\n    return capturedPicture;\n  }\n\n  public stopAsync(): void {\n    stopMediaStream(this.stream);\n    this.setStream(null);\n  }\n\n  // TODO: Bacon: we don't even use ratio in native...\n  public getAvailablePictureSizes = async (ratio: string): Promise<string[]> => {\n    return PictureSizes;\n  };\n\n  static async getAvailableCameraTypesAsync(): Promise<string[]> {\n    if (!canGetUserMedia() || !navigator.mediaDevices.enumerateDevices) return [];\n\n    const devices = await navigator.mediaDevices.enumerateDevices();\n\n    const types: (string | null)[] = await Promise.all([\n      (await isFrontCameraAvailableAsync(devices)) && CameraType.front,\n      (await isBackCameraAvailableAsync()) && CameraType.back,\n    ]);\n\n    return types.filter(Boolean) as string[];\n  }\n}\n\nfunction stopMediaStream(stream: MediaStream | null) {\n  if (!stream) return;\n  if (stream.getAudioTracks) stream.getAudioTracks().forEach(track => track.stop());\n  if (stream.getVideoTracks) stream.getVideoTracks().forEach(track => track.stop());\n  if (isMediaStreamTrack(stream)) stream.stop();\n}\n\nfunction setVideoSource(\n  video: HTMLVideoElement,\n  stream: MediaStream | MediaSource | Blob | null\n): void {\n  try {\n    video.srcObject = stream;\n  } catch (_) {\n    if (stream) {\n      video.src = window.URL.createObjectURL(stream);\n    } else if (typeof video.src === 'string') {\n      window.URL.revokeObjectURL(video.src);\n    }\n  }\n}\n\nasync function applyConstraints(\n  tracks: MediaStreamTrack[],\n  constraints: { [key: string]: any }\n): Promise<boolean> {\n  try {\n    await Promise.all(\n      tracks.map(async track => {\n        await track.applyConstraints({ advanced: [constraints] as any });\n      })\n    );\n    return true;\n  } catch (_) {\n    return false;\n  }\n}\n\nfunction isCapabilityAvailable(video: HTMLVideoElement, keyName: string): boolean {\n  const stream = video.srcObject;\n\n  if (stream instanceof MediaStream) {\n    const videoTrack = stream.getVideoTracks()[0];\n\n    if (typeof videoTrack.getCapabilities === 'undefined') {\n      return false;\n    }\n\n    const capabilities: any = videoTrack.getCapabilities();\n\n    return !!capabilities[keyName];\n  }\n\n  return false;\n}\n\nfunction isMediaStreamTrack(input: any): input is MediaStreamTrack {\n  return typeof input.stop === 'function';\n}\n\nfunction convertNormalizedSetting(range: MediaSettingsRange, value?: number): number | undefined {\n  if (!value) return;\n  // convert the normalized incoming setting to the native camera zoom range\n  const converted = convertRange(value, [range.min, range.max]);\n  // clamp value so we don't get an error\n  return Math.min(range.max, Math.max(range.min, converted));\n}\n\nfunction convertRange(value: number, r2: number[], r1: number[] = [0, 1]): number {\n  return ((value - r1[0]) * (r2[1] - r2[0])) / (r1[1] - r1[0]) + r2[0];\n}\n\nfunction validatedConstrainedValue(\n  constraintKey: string,\n  settingsKey: string,\n  convertedSetting: any,\n  capabilities: MediaTrackCapabilities,\n  settings: any,\n  cameraType: string\n): any {\n  const setting = settings[settingsKey];\n  if (\n    Array.isArray(capabilities[constraintKey]) &&\n    convertedSetting &&\n    !capabilities[constraintKey].includes(convertedSetting)\n  ) {\n    console.warn(\n      ` { ${settingsKey}: \"${setting}\" } (converted to \"${convertedSetting}\" in the browser) is not supported for camera type \"${cameraType}\" in your browser. Using the default value instead.`\n    );\n    return undefined;\n  }\n  return convertedSetting;\n}\n\nexport default CameraModule;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}