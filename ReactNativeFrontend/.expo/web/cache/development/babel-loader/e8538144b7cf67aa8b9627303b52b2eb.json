{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { forwardRef } from 'react';\nimport createElement from \"react-native-web/dist/exports/createElement\";\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport CameraModule from \"./CameraModule/CameraModule\";\nimport CameraManager from \"./ExponentCameraManager.web\";\n\nvar ExponentCamera = function (_React$Component) {\n  _inherits(ExponentCamera, _React$Component);\n\n  var _super = _createSuper(ExponentCamera);\n\n  function ExponentCamera() {\n    var _this;\n\n    _classCallCheck(this, ExponentCamera);\n\n    _this = _super.apply(this, arguments);\n    _this.state = {\n      type: null\n    };\n\n    _this._updateCameraProps = function _callee(_ref) {\n      var type, pictureSize, webCameraSettings, _assertThisInitialize, camera, actualCameraType;\n\n      return _regeneratorRuntime.async(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              type = _ref.type, pictureSize = _ref.pictureSize, webCameraSettings = _objectWithoutProperties(_ref, [\"type\", \"pictureSize\"]);\n              _assertThisInitialize = _assertThisInitialized(_this), camera = _assertThisInitialize.camera;\n\n              if (camera) {\n                _context.next = 4;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 4:\n              _context.next = 6;\n              return _regeneratorRuntime.awrap(camera.setTypeAsync(type));\n\n            case 6:\n              _context.next = 8;\n              return _regeneratorRuntime.awrap(camera.updateWebCameraSettingsAsync(webCameraSettings));\n\n            case 8:\n              _context.next = 10;\n              return _regeneratorRuntime.awrap(camera.ensureCameraIsRunningAsync());\n\n            case 10:\n              actualCameraType = camera.getActualCameraType();\n\n              if (actualCameraType !== _this.state.type) {\n                _this.setState({\n                  type: actualCameraType\n                });\n              }\n\n            case 12:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    };\n\n    _this.getCamera = function () {\n      if (_this.camera) {\n        return _this.camera;\n      }\n\n      throw new Error('Camera is not defined yet!');\n    };\n\n    _this.getAvailablePictureSizes = function _callee2(ratio) {\n      var camera;\n      return _regeneratorRuntime.async(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              camera = _this.getCamera();\n              return _context2.abrupt(\"return\", camera.getAvailablePictureSizes(ratio));\n\n            case 2:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    };\n\n    _this.takePicture = function _callee3(options) {\n      var camera;\n      return _regeneratorRuntime.async(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              camera = _this.getCamera();\n              return _context3.abrupt(\"return\", camera.takePicture(_objectSpread(_objectSpread({}, options), {}, {\n                onPictureSaved: _this.props.onPictureSaved\n              })));\n\n            case 2:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    };\n\n    _this.resumePreview = function _callee4() {\n      var camera;\n      return _regeneratorRuntime.async(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              camera = _this.getCamera();\n              _context4.next = 3;\n              return _regeneratorRuntime.awrap(camera.resumePreview());\n\n            case 3:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    };\n\n    _this.pausePreview = function _callee5() {\n      var camera;\n      return _regeneratorRuntime.async(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              camera = _this.getCamera();\n              _context5.next = 3;\n              return _regeneratorRuntime.awrap(camera.stopAsync());\n\n            case 3:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    };\n\n    _this.onCameraReady = function () {\n      if (_this.props.onCameraReady) {\n        _this.props.onCameraReady();\n      }\n    };\n\n    _this.onMountError = function (_ref2) {\n      var nativeEvent = _ref2.nativeEvent;\n\n      if (_this.props.onMountError) {\n        _this.props.onMountError({\n          nativeEvent: nativeEvent\n        });\n      }\n    };\n\n    _this._setRef = function (ref) {\n      if (!ref) {\n        _this.video = null;\n\n        if (_this.camera) {\n          _this.camera.stopAsync();\n\n          _this.camera = undefined;\n        }\n\n        return;\n      }\n\n      _this.video = findNodeHandle(ref);\n      _this.video.webkitPlaysinline = true;\n      _this.camera = new CameraModule(ref);\n      _this.camera.onCameraReady = _this.onCameraReady;\n      _this.camera.onMountError = _this.onMountError;\n\n      _this._updateCameraProps(_this.props);\n    };\n\n    return _this;\n  }\n\n  _createClass(ExponentCamera, [{\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.camera) {\n        this.camera.stopAsync();\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(nextProps) {\n      this._updateCameraProps(nextProps);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var pointerEvents = this.props.pointerEvents;\n      var isMuted = true;\n      var isFrontFacingCamera = this.state.type === CameraManager.Type.front;\n      var style = {\n        transform: isFrontFacingCamera ? [{\n          scaleX: -1\n        }] : undefined\n      };\n      return React.createElement(View, {\n        pointerEvents: \"box-none\",\n        style: [styles.videoWrapper, this.props.style]\n      }, React.createElement(Video, {\n        autoPlay: true,\n        playsInline: true,\n        muted: isMuted,\n        pointerEvents: pointerEvents,\n        ref: this._setRef,\n        style: [StyleSheet.absoluteFill, styles.video, style]\n      }), this.props.children);\n    }\n  }]);\n\n  return ExponentCamera;\n}(React.Component);\n\nexport { ExponentCamera as default };\nvar Video = forwardRef(function (props, ref) {\n  return createElement('video', _objectSpread(_objectSpread({}, props), {}, {\n    ref: ref\n  }));\n});\nvar styles = StyleSheet.create({\n  videoWrapper: {\n    flex: 1,\n    alignItems: 'stretch'\n  },\n  video: {\n    width: '100%',\n    height: '100%',\n    objectFit: 'cover'\n  }\n});","map":{"version":3,"sources":["../src/ExponentCamera.web.tsx"],"names":[],"mappings":"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","sourcesContent":["import React, { forwardRef } from 'react';\nimport { createElement, findNodeHandle, StyleSheet, View } from 'react-native';\n\nimport {\n  CameraCapturedPicture,\n  CameraMountError,\n  CameraNativeProps,\n  CameraPictureOptions,\n} from './Camera.types';\nimport CameraModule, { CameraType } from './CameraModule/CameraModule';\nimport CameraManager from './ExponentCameraManager.web';\n\nexport default class ExponentCamera extends React.Component<CameraNativeProps> {\n  video?: number | null;\n  camera?: CameraModule;\n\n  state = { type: null };\n\n  componentWillUnmount() {\n    if (this.camera) {\n      this.camera.stopAsync();\n    }\n  }\n\n  componentDidUpdate(nextProps) {\n    this._updateCameraProps(nextProps);\n  }\n\n  _updateCameraProps = async ({ type, pictureSize, ...webCameraSettings }: CameraNativeProps) => {\n    const { camera } = this;\n    if (!camera) {\n      return;\n    }\n\n    await camera.setTypeAsync(type as CameraType);\n\n    await camera.updateWebCameraSettingsAsync(webCameraSettings);\n\n    // await camera.setPictureSize(pictureSize as string);\n\n    await camera.ensureCameraIsRunningAsync();\n\n    const actualCameraType = camera.getActualCameraType();\n    if (actualCameraType !== this.state.type) {\n      this.setState({ type: actualCameraType });\n    }\n  };\n\n  getCamera = (): CameraModule => {\n    if (this.camera) {\n      return this.camera;\n    }\n    throw new Error('Camera is not defined yet!');\n  };\n\n  getAvailablePictureSizes = async (ratio: string): Promise<string[]> => {\n    const camera = this.getCamera();\n    return camera.getAvailablePictureSizes(ratio);\n  };\n\n  takePicture = async (options: CameraPictureOptions): Promise<CameraCapturedPicture> => {\n    const camera = this.getCamera();\n    return camera.takePicture({\n      ...options,\n      // This will always be defined, the option gets added to a queue in the upper-level. We should replace the original so it isn't called twice.\n      onPictureSaved: this.props.onPictureSaved,\n    });\n  };\n\n  resumePreview = async (): Promise<void> => {\n    const camera = this.getCamera();\n    await camera.resumePreview();\n  };\n\n  pausePreview = async (): Promise<void> => {\n    const camera = this.getCamera();\n    await camera.stopAsync();\n  };\n\n  onCameraReady = () => {\n    if (this.props.onCameraReady) {\n      this.props.onCameraReady();\n    }\n  };\n\n  onMountError = ({ nativeEvent }: { nativeEvent: CameraMountError }) => {\n    if (this.props.onMountError) {\n      this.props.onMountError({ nativeEvent });\n    }\n  };\n\n  _setRef = ref => {\n    if (!ref) {\n      this.video = null;\n      if (this.camera) {\n        this.camera.stopAsync();\n        this.camera = undefined;\n      }\n      return;\n    }\n    this.video = findNodeHandle(ref);\n\n    (this.video as any).webkitPlaysinline = true;\n\n    this.camera = new CameraModule(ref);\n    this.camera.onCameraReady = this.onCameraReady;\n    this.camera.onMountError = this.onMountError;\n    this._updateCameraProps(this.props);\n  };\n\n  render() {\n    const { pointerEvents } = this.props;\n\n    // TODO: Bacon: Create a universal prop, on native the microphone is only used when recording videos.\n    // Because we don't support recording video in the browser we don't need the user to give microphone permissions.\n    const isMuted = true;\n\n    const isFrontFacingCamera = this.state.type === CameraManager.Type.front;\n    const style = {\n      // Flip the camera\n      transform: isFrontFacingCamera ? [{ scaleX: -1 }] : undefined,\n    };\n\n    return (\n      <View pointerEvents=\"box-none\" style={[styles.videoWrapper, this.props.style]}>\n        <Video\n          autoPlay\n          playsInline\n          muted={isMuted}\n          pointerEvents={pointerEvents}\n          ref={this._setRef}\n          style={[StyleSheet.absoluteFill, styles.video, style]}\n        />\n        {this.props.children}\n      </View>\n    );\n  }\n}\n\nconst Video: any = forwardRef((props, ref) => createElement('video', { ...props, ref }));\n\nconst styles = StyleSheet.create({\n  videoWrapper: {\n    flex: 1,\n    alignItems: 'stretch',\n  },\n  video: {\n    width: '100%',\n    height: '100%',\n    objectFit: 'cover',\n  },\n});\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}