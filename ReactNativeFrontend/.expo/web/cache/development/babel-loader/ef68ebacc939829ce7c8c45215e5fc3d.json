{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport { EventEmitter } from 'fbemitter';\nimport { vec2 } from 'gl-matrix';\n\nvar SignatureBezierProvider = function (_EventEmitter) {\n  _inherits(SignatureBezierProvider, _EventEmitter);\n\n  var _super = _createSuper(SignatureBezierProvider);\n\n  function SignatureBezierProvider() {\n    var _this;\n\n    _classCallCheck(this, SignatureBezierProvider);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.nextPointIndex = 0;\n    _this.points = new Array(SignatureBezierProvider.pointsPerLine).fill(SignatureBezierProvider.dotWeight).map(function (weight) {\n      return {\n        point: vec2.create(),\n        weight: weight\n      };\n    });\n    return _this;\n  }\n\n  _createClass(SignatureBezierProvider, [{\n    key: \"addPointToSignature\",\n    value: function addPointToSignature(point) {\n      var isEndOfLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (this.isFirstPoint) {\n        this.startNewLine(point, SignatureBezierProvider.dotWeight);\n      } else {\n        var previousPoint = this.previousPoint;\n\n        if (vec2.length(previousPoint, point) < SignatureBezierProvider.touchDistanceThreshold) {\n          return;\n        }\n\n        if (this.isStartOfNextLine) {\n          this.finalizeBezier(point);\n          this.startNewLine(this.points[3].point, this.points[3].weight);\n        }\n\n        this.addPointAndWeight(point, SignatureBezierProvider.signatureWeightForLine(previousPoint, point));\n      }\n\n      this.generateBezierPath(this.nextPointIndex - 1, isEndOfLine);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.nextPointIndex = 0;\n    }\n  }, {\n    key: \"finalizeBezier\",\n    value: function finalizeBezier(point3rd) {\n      var point2nd = this.points[2].point;\n      var pointAvg = this.points[3].point;\n      vec2.scale(pointAvg, vec2.add(pointAvg, point2nd, point3rd), 0.5);\n      this.points[3].weight = SignatureBezierProvider.signatureWeightForLine(point2nd, pointAvg);\n      this.generateBezierPath(3, true);\n    }\n  }, {\n    key: \"generateBezierPath\",\n    value: function generateBezierPath(index) {\n      var finalized = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this.emit(SignatureBezierProvider.EVENT_DRAW_PATH, SignatureBezierProvider.paths[index], this.points, finalized);\n    }\n  }, {\n    key: \"startNewLine\",\n    value: function startNewLine(point, weight) {\n      this.nextPointIndex = 0;\n      this.addPointAndWeight(point, weight);\n    }\n  }, {\n    key: \"addPointAndWeight\",\n    value: function addPointAndWeight(point, weight) {\n      vec2.copy(this.points[this.nextPointIndex].point, point);\n      this.points[this.nextPointIndex].weight = weight;\n      this.nextPointIndex += 1;\n    }\n  }, {\n    key: \"isFirstPoint\",\n    get: function get() {\n      return this.nextPointIndex === 0;\n    }\n  }, {\n    key: \"isStartOfNextLine\",\n    get: function get() {\n      return this.nextPointIndex >= SignatureBezierProvider.pointsPerLine;\n    }\n  }, {\n    key: \"previousPoint\",\n    get: function get() {\n      return this.points[this.nextPointIndex - 1].point;\n    }\n  }], [{\n    key: \"signatureWeightForLine\",\n    value: function signatureWeightForLine(pointA, pointB) {\n      var maxLengthRange = SignatureBezierProvider.maxWeight * 10;\n      var gradient = 0.1;\n      var constant = SignatureBezierProvider.minWeight;\n      var length = vec2.distance(pointA, pointB);\n      var inversedLength = Math.max(maxLengthRange - length, 0);\n      return inversedLength * gradient + constant;\n    }\n  }]);\n\n  return SignatureBezierProvider;\n}(EventEmitter);\n\nSignatureBezierProvider.dotWeight = 3;\nSignatureBezierProvider.pointsPerLine = 4;\nSignatureBezierProvider.touchDistanceThreshold = 2;\nSignatureBezierProvider.maxWeight = 10;\nSignatureBezierProvider.minWeight = 2;\nSignatureBezierProvider.paths = ['dot', 'line', 'quadCurve', 'bezierCurve'];\nSignatureBezierProvider.EVENT_DRAW_PATH = 'drawPath';\nexport default SignatureBezierProvider;","map":{"version":3,"sources":["/Users/cosentus/Documents/GitHub/SIH-Project/ReactNativeFrontend/node_modules/expo-pixi/lib/core/signature/SignatureBezierProvider.js"],"names":["EventEmitter","vec2","SignatureBezierProvider","nextPointIndex","points","Array","pointsPerLine","fill","dotWeight","map","weight","point","create","isEndOfLine","isFirstPoint","startNewLine","previousPoint","length","touchDistanceThreshold","isStartOfNextLine","finalizeBezier","addPointAndWeight","signatureWeightForLine","generateBezierPath","point3rd","point2nd","pointAvg","scale","add","index","finalized","emit","EVENT_DRAW_PATH","paths","copy","pointA","pointB","maxLengthRange","maxWeight","gradient","constant","minWeight","distance","inversedLength","Math","max"],"mappings":"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","sourcesContent":["//@flow\nimport { EventEmitter } from 'fbemitter';\nimport { vec2 } from 'gl-matrix';\n\nclass SignatureBezierProvider extends EventEmitter {\n  static dotWeight = 3;\n  static pointsPerLine = 4;\n  static touchDistanceThreshold = 2;\n  static maxWeight = 10;\n  static minWeight = 2;\n\n  static paths = ['dot', 'line', 'quadCurve', 'bezierCurve'];\n\n  static EVENT_DRAW_PATH = 'drawPath';\n\n  static signatureWeightForLine(pointA, pointB) {\n    /**\n     * The is the maximum length that will vary weight.\n     * Anything higher will return the same weight.\n     */\n    const maxLengthRange = SignatureBezierProvider.maxWeight * 10;\n\n    /**\n     * These are based on having a minimum line thickness of 2.0 and maximum of 10.0,\n     * linearly over line lengths 0-maxLengthRange.\n     * They fit into a typical linear equation: y = mx + c\n     *\n     * Note: Only the points of the two parallel bezier curves will be\n     * at least as thick as the constant. The bezier curves themselves\n     * could still be drawn with sharp angles, meaning there is no true\n     * 'minimum thickness' of the signature.\n     */\n    const gradient = 0.1;\n    const constant = SignatureBezierProvider.minWeight;\n\n    const length = vec2.distance(pointA, pointB);\n    const inversedLength = Math.max(maxLengthRange - length, 0);\n    return inversedLength * gradient + constant;\n  }\n\n  nextPointIndex = 0;\n  points = new Array(SignatureBezierProvider.pointsPerLine)\n    .fill(SignatureBezierProvider.dotWeight)\n    .map(weight => ({ point: vec2.create(), weight }));\n\n  addPointToSignature(point, isEndOfLine = false) {\n    if (this.isFirstPoint) {\n      this.startNewLine(point, SignatureBezierProvider.dotWeight);\n    } else {\n      let previousPoint = this.previousPoint;\n      if (vec2.length(previousPoint, point) < SignatureBezierProvider.touchDistanceThreshold) {\n        return;\n      }\n      if (this.isStartOfNextLine) {\n        this.finalizeBezier(point);\n        this.startNewLine(this.points[3].point, this.points[3].weight);\n      }\n\n      this.addPointAndWeight(\n        point,\n        SignatureBezierProvider.signatureWeightForLine(previousPoint, point)\n      );\n    }\n\n    this.generateBezierPath(this.nextPointIndex - 1, isEndOfLine);\n  }\n\n  reset() {\n    this.nextPointIndex = 0;\n  }\n\n  finalizeBezier(point3rd) {\n    /**\n     * Smooth the join between beziers by modifying the last point of the current bezier\n     * to equal the average of the points either side of it.\n     */\n    const point2nd = this.points[2].point;\n    const pointAvg = this.points[3].point;\n    vec2.scale(pointAvg, vec2.add(pointAvg, point2nd, point3rd), 0.5);\n    this.points[3].weight = SignatureBezierProvider.signatureWeightForLine(point2nd, pointAvg);\n\n    this.generateBezierPath(3, true);\n  }\n\n  generateBezierPath(index, finalized = false) {\n    this.emit(\n      SignatureBezierProvider.EVENT_DRAW_PATH,\n      SignatureBezierProvider.paths[index],\n      this.points,\n      finalized\n    );\n  }\n\n  startNewLine(point, weight) {\n    this.nextPointIndex = 0;\n    this.addPointAndWeight(point, weight);\n  }\n\n  addPointAndWeight(point, weight) {\n    vec2.copy(this.points[this.nextPointIndex].point, point);\n    this.points[this.nextPointIndex].weight = weight;\n    this.nextPointIndex += 1;\n  }\n\n  get isFirstPoint() {\n    return this.nextPointIndex === 0;\n  }\n\n  get isStartOfNextLine() {\n    return this.nextPointIndex >= SignatureBezierProvider.pointsPerLine;\n  }\n\n  get previousPoint() {\n    return this.points[this.nextPointIndex - 1].point;\n  }\n}\n\nexport default SignatureBezierProvider;\n"]},"metadata":{},"sourceType":"module"}