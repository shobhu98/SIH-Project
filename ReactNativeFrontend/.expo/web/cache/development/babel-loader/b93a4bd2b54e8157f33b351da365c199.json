{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"/Users/cosentus/Documents/GitHub/SIH-Project/ReactNativeFrontend/node_modules/expo-pixi/lib/components/Sketch.js\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport { GLView } from 'expo-gl';\nimport React from 'react';\nimport PanResponder from \"react-native-web/dist/exports/PanResponder\";\nimport PixelRatio from \"react-native-web/dist/exports/PixelRatio\";\nimport PIXI from \"../Pixi\";\nimport { takeSnapshotAsync } from \"../utils\";\nglobal.__ExpoSketchId = global.__ExpoSketchId || 0;\nvar scale = PixelRatio.get();\n\nfunction scaled(_ref) {\n  var x = _ref.locationX,\n      y = _ref.locationY;\n  return {\n    x: x * scale,\n    y: y * scale\n  };\n}\n\nvar Sketch = function (_React$Component) {\n  _inherits(Sketch, _React$Component);\n\n  var _super = _createSuper(Sketch);\n\n  function Sketch() {\n    var _this;\n\n    _classCallCheck(this, Sketch);\n\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(_args));\n    _this.lines = [];\n    _this.points = [];\n    _this.ease = 0.3;\n    _this.delay = 10;\n\n    _this.setupPanResponder = function () {\n      var onEnd = function onEnd(event) {\n        _this.drawLine(scaled(event), false);\n\n        setTimeout(function () {\n          return _this.props.onChange && _this.props.onChange(_this.renderer);\n        }, 1);\n      };\n\n      _this.panResponder = PanResponder.create({\n        onStartShouldSetResponder: function onStartShouldSetResponder() {\n          return true;\n        },\n        onStartShouldSetPanResponderCapture: function onStartShouldSetPanResponderCapture() {\n          return true;\n        },\n        onMoveShouldSetPanResponder: function onMoveShouldSetPanResponder(evt, gestureState) {\n          return true;\n        },\n        onPanResponderGrant: function onPanResponderGrant(_ref2) {\n          var nativeEvent = _ref2.nativeEvent;\n\n          var _scaled = scaled(nativeEvent),\n              x = _scaled.x,\n              y = _scaled.y;\n\n          var _this$props = _this.props,\n              color = _this$props.strokeColor,\n              width = _this$props.strokeWidth,\n              alpha = _this$props.strokeAlpha;\n\n          _this.drawLine({\n            x: x,\n            y: y,\n            color: color,\n            width: width,\n            alpha: alpha\n          }, true);\n        },\n        onPanResponderMove: function onPanResponderMove(_ref3) {\n          var nativeEvent = _ref3.nativeEvent;\n          var point = scaled(nativeEvent);\n          var time = Date.now();\n          var delta = time - _this.lastTime;\n          if (delta < _this.delay) return;\n          _this.lastTime = time;\n\n          _this.drawLine({\n            x: _this.lastPoint.x + _this.ease * (point.x - _this.lastPoint.x),\n            y: _this.lastPoint.y + _this.ease * (point.y - _this.lastPoint.y),\n            color: _this.props.strokeColor,\n            width: _this.props.strokeWidth,\n            alpha: _this.props.strokeAlpha\n          }, false);\n        },\n        onPanResponderRelease: function onPanResponderRelease(_ref4) {\n          var nativeEvent = _ref4.nativeEvent;\n          return onEnd(nativeEvent);\n        },\n        onPanResponderTerminate: function onPanResponderTerminate(_ref5) {\n          var nativeEvent = _ref5.nativeEvent;\n          return onEnd(nativeEvent);\n        }\n      });\n    };\n\n    _this.shouldComponentUpdate = function () {\n      return false;\n    };\n\n    _this.persistStroke = function () {\n      if (_this.graphics) {\n        _this.graphics.points = _this.points;\n\n        _this.lines.push(_this.graphics);\n      }\n\n      _this.lastTime = 0;\n      _this.points = [];\n    };\n\n    _this.undo = function () {\n      if (!_this.renderer) {\n        return null;\n      }\n\n      var children = _this.stage.children;\n\n      if (children.length > 0) {\n        var child = children[children.length - 1];\n\n        _this.stage.removeChild(child);\n\n        _this.renderer._update();\n\n        setTimeout(function () {\n          return _this.props.onChange && _this.props.onChange(_this.renderer);\n        }, 2);\n        return child;\n      } else if (_this.points.length > 0) {\n        _this.persistStroke();\n\n        return _this.undo();\n      }\n    };\n\n    _this.clear = function () {\n      _this.provider.reset();\n\n      if (!_this.renderer) {\n        return null;\n      }\n\n      if (_this.stage.children.length > 0) {\n        _this.stage.removeChildren();\n\n        _this.renderer._update();\n      }\n\n      return null;\n    };\n\n    _this.takeSnapshotAsync = function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return takeSnapshotAsync.apply(void 0, [_this.glView].concat(args));\n    };\n\n    _this.onContextCreate = function _callee(context) {\n      var getAttributes, initialLines, _iterator, _step, line;\n\n      return _regeneratorRuntime.async(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _this.context = context;\n              _this.stage = new PIXI.Container();\n\n              getAttributes = context.getContextAttributes || function () {\n                return {};\n              };\n\n              context.getContextAttributes = function () {\n                var contextAttributes = getAttributes();\n                return _objectSpread(_objectSpread({}, contextAttributes), {}, {\n                  stencil: true\n                });\n              };\n\n              _this.renderer = PIXI.autoDetectRenderer(context.drawingBufferWidth, context.drawingBufferHeight, {\n                context: context,\n                antialias: true,\n                backgroundColor: 'transparent',\n                transparent: true,\n                autoStart: false\n              });\n\n              _this.renderer._update = function () {\n                _this.renderer.render(_this.stage);\n\n                context.endFrameEXP();\n              };\n\n              _this.props.onReady && _this.props.onReady(context);\n              initialLines = _this.props.initialLines;\n\n              if (initialLines) {\n                for (_iterator = _createForOfIteratorHelperLoose(initialLines); !(_step = _iterator()).done;) {\n                  line = _step.value;\n\n                  _this.buildLine(line);\n                }\n\n                _this.lines = initialLines;\n              }\n\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    };\n\n    _this.buildLine = function (_ref6) {\n      var points = _ref6.points,\n          color = _ref6.color,\n          alpha = _ref6.alpha,\n          width = _ref6.width;\n\n      for (var i = 0; i < points.length; i++) {\n        _this.drawLine(_objectSpread({\n          color: color,\n          alpha: alpha,\n          width: width\n        }, points[i]), i === 0);\n      }\n    };\n\n    _this.onLayout = function (_ref7) {\n      var _ref7$nativeEvent$lay = _ref7.nativeEvent.layout,\n          width = _ref7$nativeEvent$lay.width,\n          height = _ref7$nativeEvent$lay.height;\n\n      if (_this.renderer) {\n        var _scale = PixelRatio.get();\n\n        _this.renderer.resize(width * _scale, height * _scale);\n\n        _this.renderer._update();\n      }\n    };\n\n    _this.setRef = function (ref) {\n      _this.glView = ref;\n    };\n\n    return _this;\n  }\n\n  _createClass(Sketch, [{\n    key: \"componentWillMount\",\n    value: function componentWillMount() {\n      global.__ExpoSketchId++;\n      this.setupPanResponder();\n    }\n  }, {\n    key: \"drawLine\",\n    value: function drawLine(point, newLine) {\n      if (!this.renderer || !newLine && !this.graphics) {\n        return;\n      }\n\n      if (newLine) {\n        this.persistStroke();\n        this.graphics = new PIXI.Graphics();\n        this.stage.addChild(this.graphics);\n        this.lastPoint = point;\n        this.points = [point];\n        return;\n      }\n\n      this.lastPoint = point;\n      this.points.push(point);\n      this.graphics.clear();\n\n      for (var i = 0; i < this.points.length; i++) {\n        var _this$points$i = this.points[i],\n            x = _this$points$i.x,\n            y = _this$points$i.y,\n            color = _this$points$i.color,\n            width = _this$points$i.width,\n            alpha = _this$points$i.alpha;\n\n        if (i === 0) {\n          this.graphics.lineStyle(width || this.props.strokeWidth || 10, color || this.props.strokeColor || 0x000000, alpha || this.props.strokeAlpha || 1);\n          this.graphics.moveTo(x, y);\n        } else {\n          this.graphics.lineTo(x, y);\n        }\n      }\n\n      this.graphics.currentPath.shape.closed = false;\n      this.graphics.endFill();\n\n      this.renderer._update();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React.createElement(GLView, _extends({}, this.panResponder.panHandlers, {\n        onLayout: this.onLayout,\n        key: 'Expo.Sketch-' + global.__ExpoSketchId,\n        ref: this.setRef\n      }, this.props, {\n        onContextCreate: this.onContextCreate,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 245,\n          columnNumber: 7\n        }\n      }));\n    }\n  }]);\n\n  return Sketch;\n}(React.Component);\n\nexport { Sketch as default };","map":{"version":3,"sources":["/Users/cosentus/Documents/GitHub/SIH-Project/ReactNativeFrontend/node_modules/expo-pixi/lib/components/Sketch.js"],"names":["GLView","React","PIXI","takeSnapshotAsync","global","__ExpoSketchId","scale","PixelRatio","get","scaled","x","locationX","y","locationY","Sketch","lines","points","ease","delay","setupPanResponder","onEnd","event","drawLine","setTimeout","props","onChange","renderer","panResponder","PanResponder","create","onStartShouldSetResponder","onStartShouldSetPanResponderCapture","onMoveShouldSetPanResponder","evt","gestureState","onPanResponderGrant","nativeEvent","color","strokeColor","width","strokeWidth","alpha","strokeAlpha","onPanResponderMove","point","time","Date","now","delta","lastTime","lastPoint","onPanResponderRelease","onPanResponderTerminate","shouldComponentUpdate","persistStroke","graphics","push","undo","children","stage","length","child","removeChild","_update","clear","provider","reset","removeChildren","args","glView","onContextCreate","context","Container","getAttributes","getContextAttributes","contextAttributes","stencil","autoDetectRenderer","drawingBufferWidth","drawingBufferHeight","antialias","backgroundColor","transparent","autoStart","render","endFrameEXP","onReady","initialLines","line","buildLine","i","onLayout","layout","height","resize","setRef","ref","newLine","Graphics","addChild","lineStyle","moveTo","lineTo","currentPath","shape","closed","endFill","panHandlers","Component"],"mappings":"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","sourcesContent":["//@flow\nimport { GLView } from 'expo-gl';\nimport React from 'react';\nimport { PanResponder, PixelRatio } from 'react-native';\n\nimport PIXI from '../Pixi';\nimport { takeSnapshotAsync } from '../utils';\n\nglobal.__ExpoSketchId = global.__ExpoSketchId || 0;\n\ntype Props = {\n  strokeColor: number | string,\n  strokeWidth: number,\n  strokeAlpha: number,\n  onChange: () => PIXI.Renderer,\n  onReady: () => WebGLRenderingContext,\n  initialLines?: Array<Point>,\n};\n\nconst scale = PixelRatio.get();\n\nfunction scaled({ locationX: x, locationY: y }) {\n  return { x: x * scale, y: y * scale };\n}\n\ntype Point = {\n  x: number,\n  y: number,\n  color: string | number,\n  width: number,\n  alpha: number,\n};\n\nexport default class Sketch extends React.Component<Props> {\n  lines = [];\n  stage: PIXI.Stage;\n  graphics;\n  points = [];\n  lastPoint: Point;\n  lastTime: number;\n  ease: number = 0.3; // only move 0.3 in the direction of the pointer, this smooths it out\n  delay: number = 10;\n  panResponder: PanResponder;\n  renderer: PIXI.Renderer;\n\n  componentWillMount() {\n    global.__ExpoSketchId++;\n    this.setupPanResponder();\n  }\n\n  setupPanResponder = () => {\n    const onEnd = event => {\n      this.drawLine(scaled(event), false);\n\n      setTimeout(() => this.props.onChange && this.props.onChange(this.renderer), 1);\n    };\n\n    this.panResponder = PanResponder.create({\n      onStartShouldSetResponder: () => true,\n      onStartShouldSetPanResponderCapture: () => true,\n      onMoveShouldSetPanResponder: (evt, gestureState) => true,\n      onPanResponderGrant: ({ nativeEvent }) => {\n        const { x, y } = scaled(nativeEvent);\n        const { strokeColor: color, strokeWidth: width, strokeAlpha: alpha } = this.props;\n        this.drawLine(\n          {\n            x,\n            y,\n            color,\n            width,\n            alpha,\n          },\n          true\n        );\n      },\n      onPanResponderMove: ({ nativeEvent }) => {\n        const point = scaled(nativeEvent);\n        // throttle updates: once for every 10ms\n        const time = Date.now();\n        const delta = time - this.lastTime;\n        if (delta < this.delay) return;\n        this.lastTime = time;\n\n        this.drawLine(\n          {\n            x: this.lastPoint.x + this.ease * (point.x - this.lastPoint.x),\n            y: this.lastPoint.y + this.ease * (point.y - this.lastPoint.y),\n            color: this.props.strokeColor,\n            width: this.props.strokeWidth,\n            alpha: this.props.strokeAlpha,\n          },\n          false\n        );\n      },\n      onPanResponderRelease: ({ nativeEvent }) => onEnd(nativeEvent),\n      onPanResponderTerminate: ({ nativeEvent }) => onEnd(nativeEvent),\n    });\n  };\n\n  shouldComponentUpdate = () => false;\n\n  persistStroke = () => {\n    if (this.graphics) {\n      this.graphics.points = this.points;\n      this.lines.push(this.graphics);\n    }\n    this.lastTime = 0;\n    this.points = [];\n  };\n  drawLine(point: Point, newLine: boolean) {\n    if (!this.renderer || (!newLine && !this.graphics)) {\n      return;\n    }\n\n    if (newLine) {\n      this.persistStroke();\n      this.graphics = new PIXI.Graphics();\n      this.stage.addChild(this.graphics);\n      this.lastPoint = point;\n      this.points = [point];\n      return;\n    }\n    this.lastPoint = point;\n    this.points.push(point);\n\n    this.graphics.clear();\n    for (let i = 0; i < this.points.length; i++) {\n      const { x, y, color, width, alpha } = this.points[i];\n      if (i === 0) {\n        this.graphics.lineStyle(\n          width || this.props.strokeWidth || 10,\n          color || this.props.strokeColor || 0x000000,\n          alpha || this.props.strokeAlpha || 1\n        );\n        this.graphics.moveTo(x, y);\n      } else {\n        this.graphics.lineTo(x, y);\n      }\n    }\n    this.graphics.currentPath.shape.closed = false;\n    this.graphics.endFill(); /// TODO: this may be wrong: need stroke\n    this.renderer._update();\n  }\n\n  undo = () => {\n    if (!this.renderer) {\n      return null;\n    }\n\n    const { children } = this.stage;\n    if (children.length > 0) {\n      const child = children[children.length - 1];\n      this.stage.removeChild(child);\n      this.renderer._update();\n      // TODO: This doesn't really work :/\n      setTimeout(() => this.props.onChange && this.props.onChange(this.renderer), 2);\n      return child;\n    } else if (this.points.length > 0) {\n      this.persistStroke();\n      return this.undo();\n    }\n  };\n\n  clear = () => {\n    this.provider.reset();\n    if (!this.renderer) {\n      return null;\n    }\n\n    if (this.stage.children.length > 0) {\n      this.stage.removeChildren();\n      this.renderer._update();\n    }\n\n    return null;\n  };\n\n  takeSnapshotAsync = (...args) => {\n    return takeSnapshotAsync(this.glView, ...args);\n  };\n\n  onContextCreate = async (context: WebGLRenderingContext) => {\n    this.context = context;\n    this.stage = new PIXI.Container();\n\n    const getAttributes = context.getContextAttributes || (() => ({}));\n    context.getContextAttributes = () => {\n      const contextAttributes = getAttributes();\n      return {\n        ...contextAttributes,\n        stencil: true,\n      };\n    };\n\n    this.renderer = PIXI.autoDetectRenderer(\n      context.drawingBufferWidth,\n      context.drawingBufferHeight,\n      {\n        context,\n        antialias: true,\n        backgroundColor: 'transparent',\n        transparent: true,\n        autoStart: false,\n      }\n    );\n    this.renderer._update = () => {\n      this.renderer.render(this.stage);\n      context.endFrameEXP();\n    };\n    this.props.onReady && this.props.onReady(context);\n\n    const { initialLines } = this.props;\n    if (initialLines) {\n      for (let line of initialLines) {\n        this.buildLine(line);\n      }\n      this.lines = initialLines;\n    }\n  };\n\n  buildLine = ({ points, color, alpha, width }) => {\n    for (let i = 0; i < points.length; i++) {\n      this.drawLine({ color, alpha, width, ...points[i] }, i === 0);\n    }\n  };\n\n  onLayout = ({\n    nativeEvent: {\n      layout: { width, height },\n    },\n  }) => {\n    if (this.renderer) {\n      const scale = PixelRatio.get();\n      this.renderer.resize(width * scale, height * scale);\n      this.renderer._update();\n    }\n  };\n\n  setRef = ref => {\n    this.glView = ref;\n  };\n\n  render() {\n    return (\n      <GLView\n        {...this.panResponder.panHandlers}\n        onLayout={this.onLayout}\n        key={'Expo.Sketch-' + global.__ExpoSketchId}\n        ref={this.setRef}\n        {...this.props}\n        onContextCreate={this.onContextCreate}\n      />\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}